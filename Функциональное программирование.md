# Java Core

## Функциональное программирование

### Функциональные интерфейсы. Определение. Default & static методы. Область применения.
Функциональный интерфейс должен иметь **один единственный абстрактный метод** и любое число статических и default-методов. Для объявления такого интерфейса используется аннотация `@FunctionalInterface`. Интерфейс, помеченный этой аннотацией, предполагает его использование в виде лямбда-выражения, которое предлагает более лаконичный синтаксис при создании функций-объектов.
В Java 8 разрешено объявлять **неабстрактные** и **статические** методы в интерфейсах. Интерфейсы по-прежнему могут содержать абстрактные методы.
При реализации классом такого интерфейса реализуются только абстрактные методы, **default-методы** могут переопределяться при необходимости.
Статический метод вызывается классическим способом, без реализации содержащего его интерфейса: `Interf.method()`.
Для вызова **default-метода** необходимо предоставить реализацию интерфейса, однако сам **default-метод** переопределять не обязательно.

### Лямбда-выражение. Замыкания. Синтаксис. Характеристики.
**Лямбда-выражение** представляет сокращенную запись анонимного класса.
**Синтаксис**
```java
Service service = (int a, int b) -> {
    return 2 * (a + b);
};
Service service = (int a, int b) -> 2 * (a + b);
Service service = (a, b) -> 2 * (a + b);
```

Функция как объект создается во время выполнения. Внешне создается впечатление, что в метод передается функция. На самом деле в функцию передается объект, в который «завернута» функция. У этого объекта интересен только функционал, поэтому при практическом использовании программист может и не знать названия метода, который реально будет вызван.

Блок кода, представляющий собой лямбда-выражение вместе со значениями локальных переменных и параметров метода, в котором он объявлен, называется **замыканием**, или **closure**. Объект-функция создается во время исполнения, и применен может быть уже после того как объект, его создавший, прекратит существование. Такая ситуация требует, чтобы переменные, которые использует лямбда-выражение, не могли быть изменены. Значения переменных фиксируются замыканием и изменены быть не могут. Эти переменные должны иметь константные значения, как если бы они были объявлены как **final**. Отсюда и название — замыкание. Однако существует возможность обойти это требование и обновлять счетчик с помощью элемента массива:
```java
public static Function<String, Integer> build(String strNum) { 
    int[] count = {1};
    ++count[0];
    return t -> Integer.valueOf(strNum + t) + ++count[0];
}
```

Замыкания не запрещают использования полей класса как статических, так и нестатических. Ошибок компиляции не будет, даже если результат не может быть определен. Все требования по константности локальных переменных существовали и ранее для анонимных классов, но только с появлением лямбда-выражений проблема стала более актуальной.

### Function, Supplier, Predicate, Consumer, их применение.

#### `Function<T, R>`
Основной абстрактный метод `R apply(T t)` принимает объект типа `T` и возвращает объект типа `R`. Его задача: выполнить действие над объектом одного типа и возвратить объект другого типа.
Создание объекта `Function` может выглядеть следующим образом:
```java
Function<String, Integer> fun1 = s -> s.length();
```

Методы позволяющие построить композицию функций:
1. `default <V> Function<V, R> compose(Function<? super V, ? extends T> before)` — возвращает составную функцию, которая сначала применяет функцию `before` к своему входу, а затем применяет эту функцию к результату.
2. `default <V> Function<T,V> andThen(Function<? super R, ? extends V> after)` — возвращает составную функцию, которая сначала применяет эту функцию к своему входу, а затем применяет функцию `after` к результату.

Еще один метод `static <T> Function<T, T> identity()` — возвращает функцию, которая всегда возвращает свой входной аргумент.

Все интерфейсы пакета *java.util.function*, имеющие в своем названии слова **Function** и **Operator**, на самом деле являются вариациями интерфейса `Function<T, R>`, не наследуя его при этом.
Интерфейс `UnaryOperator<T>` объявляет метод `T apply(T t)`. Отличием этого интерфейса от `Function` является только то, что и принимаемое, и возвращаемое значения метода `T apply(T t)` должны быть одного и того же типа, что в простом примере может соответствовать оператору инкремента.
Интерфейс `BiFunction<T, U, R>` объявляет метод `R apply(T t, U u)` с двумя параметрами.
К еще более специализированным интерфейсам можно отнести: `ToIntFunction<T>` — метод которого `int applyAsInt(T t)` принимает любой тип данных, но должен возвращать значение типа `int`.
`IntFunction<R>` — наоборот, его метод `R apply(int value) `принимает значение типа `int`, но может возвращать значение любого типа.
Интерфейс `BinaryOperator<T, T>` объявляет метод `T apply(T t1, T t2)`, что соответствует обычному бинарному оператору.
К интерфейсам группы Function также можно отнести интерфейс `java.util.Comparator<T>` c его методом `int compare(T o1, T o2)`.

#### `Predicate<T>`
Интерфейс `Predicate<T>` представляет метод `boolean test(T t)`, возвращающий булево значение в зависимости от выполнения условия на объекте типа `T`. Основная область применения: выбор\поиск\фильтрация элементов из stream или коллекции по условию.
Пример реализации:
```java
Predicate<String> p = s -> s.length() < 2;
```

Композиции предикатов можно строить, используя методы:
1. `default Predicate<T> and(Predicate<? super T> other)` – лигическое и;
2. `default Predicate<T> or(Predicate<? super T> other)` – лигическое или;
3. `default Predicate<T> negate()` – логическое отрицание предиката;
4. `static Predicate<T> not(Predicate<? super T> target)` — более короткий вариант логического отрицания.
Для упрощения работы с потоками чисел разработаны предикаты `IntPredicate`, `DoublePredicate`, `LongPredicate` с практически идентичным набором методов построения логических выражений.

`static Predicate<T> isEqual(Object targetRef)` — возвращает предикат эквивалент метода `equals()` класса `Object`.

В пакете *java.util.function* объявлен еще один интерфейс-предикат `BiPredicate<T, U> ` c абстрактным методом `boolean test(T t, U u)`.

#### `Consumer<T>`
Интерфейс `Consumer<T>` представляет абстрактный метод `void accept(T t)`, функция, принимающая объект типа `T` и выполняющая над ним некоторое действие. Результат действия можно сохранить во внешнем объекте, например, коллекции или вывести в поток вывода, например, в файл или на консоль.
```java
Consumer<String> consumer = s -> System.out.println(Arrays.toString(s.split(regex)));
```

Вспомогательный метод `default Consumer<T> andThen(Consumer<? super T> after)` позволяет построить композицию из двух и более действий как одного целого.

#### `Supplier<T>`
Интерфейс `Supplier<T>` возвращает новый объект типа `T` методом `T get()`. Предназначен для создания новых объектов. Метод `get() `единственный в интерфейсе. Аналогичные интерфейсы предназначены для создания значений базовых типов:
- `BooleanSupplier` и его метод `boolean getAsBoolean()`; 
- `DoubleSupplier` и его метод `double getAsDouble()`; 
- `IntSupplier` и его метод `int getAsInt()`;
- `LongSupplier` и его метод `long getAsLong()`.

Прямое применение интерфейса для создания объектов выглядит следующим образом:
```java
Supplier<StringBuilder> supplier = () -> new StringBuilder("java"); StringBuilder builder = supplier.get();
```

Хорошим использованием Supplier может быть генератор случайных чисел или уникальных идентификаторов на его основе.

Использование Supplier методами интерфейса Stream:
- `generate(Supplier<? extends T> s)`;
- `collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator, BiConsumer<R, R> combiner)`.

### Ссылка на метод? Что это такое? Или это все же ссылка на объект?
Более короткая запись лямбда-выражения возможна в случае, если реализации функционального интерфейса необходимо передать уже существующий метод без всяких изменений.
Если задана функция получения идентификатора заказа в виде лямбда:
```java
Function<Order, Long> function = o -> o.getOrderId();
```
то можно записать ее в виде ссылки на метод:
```java
function = Order::getOrderId;
```
Для статических методов возможно представление:
```java
BiFunction<Double, Double, Double> biFunction = Math::hypot;
```

Оператор видимости **«::»** отделяет метод от объекта или класса. Существуют три варианта записи:
- **ContainingClass::staticMethodName** — ссылка на статический метод;
- **ContainingObject::instanceMethodName** — ссылка на нестатический метод конкретного объекта;
- **ContainingType::methodName** — ссылка на нестатический метод любого объекта конкретного типа.

Первые два варианта эквивалентны лямбда-выражению с параметрами методами. В третьем варианте первый параметр становится целевым для метода, например:
```java
Comparator<Long> comparator = (l1, l2) -> l1.compareTo(l2); comparator = Long::compareTo;
```
В качестве объекта можно использовать ссылки `this` и `super`.
Кроме ссылки на метод, существуют также и ссылки на конструктор, где в качестве имени метода указывается оператор `new`.
```java
Supplier<StringBuilder> supplier1 = StringBuilder::new;
```

## Stream API

### Чем Stream отличается от коллекции?
Интерфейс` java.util.stream.Stream<T>` — поток объектов для преобразования коллекций, массивов. В потоке не хранятся элементы операции, он не модифицирует источник, а формирует в ответ на действие новый поток. Операции в потоке не выполняются до момента, пока не потребуется получить конечный результат выполнения. **Stream** нельзя воспринимать как просто поток ввода/вывода. Этот поток создается на основе коллекции/массива, элементы которой переходят в состояние информационного ожидания действия, переводящего поток в следующее состояние до достижения терминальной цели, после чего поток прекращает свое существование.

### Промежуточные и терминальные операции.
#### Промежуточные
- `filter(Predicate<? super T> predicate)` – выбор элементов из потока на основании работы предиката в новый поток. Отбрасываются все элементы, не удовлетворяющие условию предиката.
- `map(Function<? super T, ? extends R> mapper)` — изменение всех элементов потока, применяя к каждому элементу функцию mapper. Тип параметризации потока может изменяться, если типизация `T` и `R` относится к различным классам.
- `flatMap(Function<T, Stream<R>> mapper)` — преобразовывает один объект, как правило составной, в объект более простой структуры, например, массив в строку, список в объект, список списков в один список.
- `peek(Consumer<T> consumer)` — возвращает поток, содержащий все элементы исходного потока. Используется для просмотра элементов в текущем состоянии потока. Можно использовать для записи логов.
- `sorted(Comparator<T> comparator) и sort()` — сортировка в новый поток.
- `limit(long maxSize)` — ограничивает количество элементов выходящего потока заданным в параметре значением.
- `skip(long n)` — не включает в выходной поток первые n элементов исходного потока.
- `distinct()` — удаляет из потока все идентичные элементы.

#### Терминальные операции
Результатом может быть новая коллекция, объект некоторого класса, число. Промежуточные операции обязательно должны завершаться терминальными, иначе они не вы- полнятся, так как просто не имеют смысла.
- `void forEach(Consumer<T> action)` — выполняет действие над каждым элементом потока. Чтобы результат действия сохранялся, реализация action должна предусматривать фиксацию результата в каком-либо объекте или потоке вывода.
- `Optional<T> findFirst()` — находит первый элемент в потоке.
- `Optional<T> findAny()` — находит элемент в потоке.
- `long count()` — возвращает число элементов потока.
- `boolean allMatch(Predicate<T> predicate)` — возвращает истину, если все элементы **stream** удовлетворяют условию предиката.
- `boolean anyMatch(Predicate<T> predicate)` — возвращает истину, если хотя бы один элемент **stream** удовлетворяет условию предиката.
- `boolean noneMatch(Predicate<T> predicate)` — возвращает истину, если ни один элемент **stream** не удовлетворяет условию предиката.
- `Optional<T> reduce(T identity, BinaryOperator<T> accumulator)` — сводит все элементы потока к одному результирующему объекту, завернутому в оболочку `Optional` применяя функцию к результату применения функции к предидущим элементам и к следующему элементу.
- `<R, A> R collect(Collector<? super T, A, R> collector)` — собирает элементы в коллекцию или объект другого типа.
- `Optional<T> min(Comparator<T> comparator)` — находит минимальный элемент.
- `Optional<T> max(Comparator<T> comparator)` — находит максимальный элемент.
