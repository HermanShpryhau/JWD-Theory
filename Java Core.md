# Java Core

### Что такое CLASSPATH. Если в CLASSPATH есть две одинаковые библиотеки (или разные версии одной библиотеки), объект класса из какой библиотеки создастся?

### Модификаторы доступа.
- **private** — члены класса доступны только членам данного класса;
- **по умолчанию (package-private)** — члены класса доступны классам, находящимся в том же пакете;
- **protected** — члены класса доступны классам, находящимся в том же пакете, и подклассам — в других пакетах;
- **public** — члены класса доступны для всех классов в этом и других пакетах.

### Что такое package level access. Пример использования.

### Как реализуется класс `String`, какие поля там есть?

### Понятие Юникод. UTF-8, описание кодировки. Отличие от UTF-16.

### `String`, `StringBuilder`, `StringBuffer`. Отличия.

### Принципы ООП.
1. **Инкапсуляция** – это механизм, который объединяет данные и код, манипулирующий этими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования.
2. **Наследование** – это процесс, посредством которого, один объект может наследовать свойства другого объекта и добавлять к ним черты, характерные только для него.
3. **Полиморфизм** – это свойсто, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач.

### Базовый класс в java. Методы класса.
На вершине иерархии классов находится класс `Object`, который является суперклассом для всех классов. Ссылочная переменная типа `Object` может указывать на объект любого другого класса, на любой массив, так как массивы реализуются как классы. В классе `Object` определен набор методов, который наследуется всеми классами:
1. `protected Object clone()` – создает и возвращает копию вызывающего объекта;
2. `public boolean equals(Object ob)` – предназначен для использования и переопределения в подклассах с выполнением общих соглашений о сравнении содержимого двух объектов одного и того же типа;
3. `public Class<? extends Object> getClass()` – возвращает объект типа Class; 
4. `protected void finalize()` – автоматически вызывается сборщиком мусора(garbage collection) перед уничтожением объекта;
5. `public int hashCode()` – вычисляет и возвращает хэш-код объекта (число, в общем случае вычисляемое на основе значений полей объекта);
6. `public String toString()` – возвращает представление объекта в виде строки. 
7. `notify()`; 
8. `notifyAll()`;
9. `wait()`;
10. `wait(int millis)`.

### Правила переопределения метода `boolean equals(Object o)`.
1. **Рефлексивность** — объект равен самому себе;
2. **Симметричность** — если `x.equals(y)` возвращает значение `true`, то и `y.equals(x)` всегда возвращает значение `true`;
3. **Транзитивность** — если метод equals() возвращает значение true при сравнении объектов x и y, а также y и z, то и при сравнении x и z будет возвращено значение `true`;
4. **Непротиворечивость** – при многократном вызове метода для двух не подвергшихся изменению за это время объектов возвращаемое значение всегда должно быть одинаковым;
5. **Ненулевая ссылка** – при сравнении с литералом `null` всегда возвращает значение `false`.

### Правила переопределения метода `int hashCode()`. Можно ли в качестве результата возвращать константу?
1. Все одинаковые по содержанию объекты одного типа должны иметь одинаковые хэш-коды.
2. Различные по содержанию объекты одного типа могут иметь различные хэш-коды.
4. Во время работы приложения значение хэш-кода объекта не изменяется, если объект не был изменен.

### Метод `clone()`. Правила переопределения метода `clone()`.
Класс `Object` содержит protected-метод `clone()`, осуществляющий побитовое копирование объекта производного класса. Однако сначала необходимо переопределить метод `clone()` как `public` для обеспечения возможности вызова из другого пакета. В переопределенном методе следует вызвать базовую версию метода `super.clone()`, которая и выполняет собственно клонирование. Чтобы окончательно сделать объект клонируемым, класс должен реализовать интерфейс `Cloneable`. Интерфейс `Cloneable` не содержит методов, относится к помеченным (tagged) интерфейсам, а его реализация гарантирует, что метод `clone() `класса `Object` возвратит точную копию вызвавшего его объекта с воспроизведением значений всех его полей. В противном случае метод генерирует исключение `CloneNotSupportedException`. Следует отметить, что при использовании этого механизма объект создается без вызова конструктора.
Обязательно, чтобы различались ссылки на клонируемый объект и клон. Желательно, чтобы у них совпадали классы, и `equals()` возвращал `true`.

### Какие идентификаторы по умолчанию имеют поля интерфейса?
`public static final`

### Перегрузка и переопределение. Можно ли менять модификатор доступа метода, если да, то каким образом?
Метод называется **перегруженным**, если существует несколько его версий с одним и тем же именем, но с разным списком параметров. **Перегрузка реализует «раннее связывание»**, то есть версия вызываемого метода определяется на этапе компиляции. Перегрузка может ограничиваться одним классом. Методы с одинаковыми именами, но с различными списком параметров и возвращаемыми значениями могут находиться в разных классах одной цепочки наследования и также будут перегруженными. Если списки параметров идентичны, то имеет место **механизм динамического полиморфизма** — **переопределение метода**.
Статические методы могут перегружаться нестатическими, и наоборот, без ограничений.

### Перегрузка и переопределение. Можно ли менять возвращаемый тип метода, если да, то как? Можно ли менять тип передаваемых параметров?

### Свойства конструктора. Способы его вызова.
**Конструктор** — особого вида метод, который по имени автоматически вызывается при создании экземпляра класса с помощью оператора `new`. Конструктор не возвращает значение, но может иметь параметры и быть перегружаемым. Конструкторов в классе может быть несколько, но не менее одного.
При корректном проектировании класса конструктор не должен выполнять никаких других обязанностей, кроме инициализации полей класса и проверки непротиворечивости конструирования объекта.
Если конструктор в классе явно не определен, то компилятор предоставляет конструктор по умолчанию без параметров, который инициализирует каждое поле класса значением по умолчанию, соответствующим его типу, например: `0`, `false`, `null`. Если же конструктор с параметрами определен, то конструктор по умолчанию становится недоступным и для его вызова необходимо явное объявление такого конструктора. Конструктор подкласса при его создании всегда наделяется возможностью вызова конструктора суперкласса. Этот вызов может быть явным или неявным и всегда располагается в первой строке кода конструктора подкласса. Если конструктору суперкласса нужно передать параметры, то необходим явный вызов из конструктора порожденного класса `super(список_параметров)`. 

### Mutable и Immutable классы. Привести примеры из java core. Как создать класс, который будет immutable. Класс record.
1. Запретить расширение класса – сделать его `final`.
2. Сделать все поля `final`.
3. Не должно быть методов, которые могут изменить состояние объекта.
4. Не возвращать наружу ссылки на ссылочные поля класса.

Начиная с версии Java 16 в язык была добавлена новая функциональность - Records (на русском нередко называют "записями"). Records представляют классы, которые предназначены для создания контейнеров неизменяемых данных. Кроме того, records позволяют упростить разработку, сократив объем кода.

Для определения классов record применяется ключевое слово `record`, после которого идет название и далее в круглых скобках список полей record:
```java
record название (поле1, поле2,...полеN) {
    // тело record
}
```

При необходимости мы можем изменить логику конструктора.

Следует учитывать, что мы не можем наследовать запись record от других классов. Также нельзя наследовать классы от records. Однако классы record могут реализовать интерфейсы. Кроме того, классы record не могут быть абстрактными.
В record нельзя явным образом определять нестатические поля и инициализаторы. Но можно определять статические переменные и инициализаторы, также как статические и нестатические методы.

### Внутренние классы, какие бывают и для каких целей используются. Области видимости данных при определенных ситуациях.
#### Внутренние (Inner) классы
**Нестатические вложенные классы** принято называть внутренними (inner). Доступ к элементам внутреннего класса возможен из внешнего только через объект внутреннего класса, который должен быть создан в коде метода внешнего класса. Объект внутреннего класса всегда ассоциируется (скрыто хранит ссылку) с создавшим его объектом внешнего класса – так называемым внешним (enclosing) объектом.
Методы внутреннего класса имеют прямой доступ ко всем полям и методам внешнего класса, в то же время внешний класс может получить доступ к содержимому внутреннего класса только после создания объекта внутреннего класса. Доступ будет разрешен по имени в том числе и к полям, объявленным как `private`. Внутренние классы не могут содержать статические атрибуты и методы, кроме констант (`final static`). Внутренние классы имеют право наследовать другие классы, реализовывать интерфейсы и выступать в роли объектов наследования.

#### Вложенные (nested) классы
Если не существует жесткой необходимости в связи объекта внутреннего класса с объектом внешнего класса, то есть смысл сделать такой класс статическим.
Вложенный класс логически связан с классом-владельцем, но может быть использован независимо от него.
При объявлении такого внутреннего класса присутствует служебное слово `static`, и такой класс называется вложенным (nested). Если класс вложен в интерфейс, то он становится статическим по умолчанию. Такой класс способен наследовать другие классы, реализовывать интерфейсы и являться объектом наследования для любого класса, обладающего необходимыми правами доступа. В то же время статический вложенный класс для доступа к нестатическим членам и методам внешнего класса должен создавать объект внешнего класса, а напрямую имеет доступ только к статическим полям и методам внешнего класса. Для создания объекта вложенного класса объект внешнего класса создавать нет необходимости. Подкласс вложенного класса не способен унаследовать возможность доступа к членам внешнего класса, которыми наделен его суперкласс. Если предполагается использовать внутренний класс в качестве подкласса, следует исключить использование в его теле любых прямых обращений к членам класса владельца.

### Анонимные классы. Практическое применение.
Анонимные (безымянные) классы применяются для придания уникальной функциональности отдельно взятому экземпляру, для обработки событий, реализации блоков прослушивания, реализации интерфейсов, запуска потоков и т. д. Можно объявить анонимный класс, который будет расширять другой класс или реализовывать интерфейс при объявлении единственного объекта, когда остальным объектам этого класса будет соответствовать реализация метода, определенная в самом классе. Объявление анонимного класса выполняется одновременно с созданием его объекта посредством оператора new.
Анонимные классы эффективно используются, как правило, для реализации (переопределения) нескольких методов и создания собственных методов объекта. Этот прием эффективен в случае, когда необходимо переопределение метода, но создавать новый класс нет необходимости из-за узкой области (или одноразового) применения метода.
Конструктор анонимного класса определить невозможно.

### Что такое enum? Область применения. Какое использование перечисления некорректно? Привести примеры.
Типобезопасные перечисления (typesafe enums) в Java представляют собой классы и являются подклассами абстрактного класса `java.lang.Enum`. Вместо слова `class` при описании перечисления используется слово `enum`. При этом объекты перечисления инициализируются прямым объявлением без помощи оператора `new`. При инициализации хотя бы одного перечисления происходит инициализация всех без исключения оставшихся элементов данного перечисления.


## I/O

### Что такое сериализация, для чего нужна, когда применяется? Ключевое слово `transient`, для чего нужно? Сериализация `static`-полей.
**Сериализация** – это процесс сохранения состояния объекта в виде последовательности байтов. **Десериализация** – процесс восстановления объекта из этих байтов.

- `transient` поля не сериализуются (если на xml).
- `static` поля не сериализуются.

При десиреализации **конструктор не вызывается**. Поля не сериализуемых классов (не реализующих интерфейс `Serialiazable`) инициализируются вызовом конструктора без параметров.


### Что такое `ClassLoader`? Если изменить static переменную в классе, загруженном одним `ClassLoader`, что будет видно в том же классе, загруженном другим. Возможно ли синглтоны создавать несколько раз?


## Exception Handling

### Опишите иерархию исключений.

### Что такое checked и unchecked Exception? Их отличия.

### Что такое `Error`. Перехват `Error`. Можно ли, есть ли смысл, в каких случаях возникает и что с ним делать.

### Оператор `throw`. Как работает? Какие свойства?


## Collections

### Основные интерфейсы коллекций и их иерархия (`List`, `Set`, `Queue`). Какие бывают коллекции? В чём особенности разных видов коллекций? Когда какие стоит применять?

### Коллекции из пакета concurrent. Их особенности.

### Метод для преобразования потоко-небезопасной коллекции в потоко-безопасную.

### Как быстро получить копию коллекции. Записать код преобразования.